// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        v6.32.0
// source: task_registry.proto

package ttmeshproto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Optional contract describing expected inputs/outputs of a task.
// This is advisory and can be used by UIs/validators. The actual runtime
// enforcement happens using Invoke params and worker-side validation.
type IOContract struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Expected input parameters. Names must be unique within the task.
	Inputs []*ParamDescriptor `protobuf:"bytes,1,rep,name=inputs,proto3" json:"inputs,omitempty"`
	// Expected outputs by name (advisory). Use OutputDescriptor for light hints.
	Outputs       []*OutputDescriptor `protobuf:"bytes,2,rep,name=outputs,proto3" json:"outputs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IOContract) Reset() {
	*x = IOContract{}
	mi := &file_task_registry_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IOContract) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IOContract) ProtoMessage() {}

func (x *IOContract) ProtoReflect() protoreflect.Message {
	mi := &file_task_registry_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IOContract.ProtoReflect.Descriptor instead.
func (*IOContract) Descriptor() ([]byte, []int) {
	return file_task_registry_proto_rawDescGZIP(), []int{0}
}

func (x *IOContract) GetInputs() []*ParamDescriptor {
	if x != nil {
		return x.Inputs
	}
	return nil
}

func (x *IOContract) GetOutputs() []*OutputDescriptor {
	if x != nil {
		return x.Outputs
	}
	return nil
}

// Lightweight output descriptor for advertising purposes.
type OutputDescriptor struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`                            // logical output name (e.g., "video", "log")
	MediaType     string                 `protobuf:"bytes,2,opt,name=media_type,json=mediaType,proto3" json:"media_type,omitempty"` // MIME (e.g., "application/octet-stream")
	SchemaRef     string                 `protobuf:"bytes,3,opt,name=schema_ref,json=schemaRef,proto3" json:"schema_ref,omitempty"` // optional schema/IDL reference
	Streamed      bool                   `protobuf:"varint,4,opt,name=streamed,proto3" json:"streamed,omitempty"`                   // whether output may stream
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OutputDescriptor) Reset() {
	*x = OutputDescriptor{}
	mi := &file_task_registry_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OutputDescriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OutputDescriptor) ProtoMessage() {}

func (x *OutputDescriptor) ProtoReflect() protoreflect.Message {
	mi := &file_task_registry_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OutputDescriptor.ProtoReflect.Descriptor instead.
func (*OutputDescriptor) Descriptor() ([]byte, []int) {
	return file_task_registry_proto_rawDescGZIP(), []int{1}
}

func (x *OutputDescriptor) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *OutputDescriptor) GetMediaType() string {
	if x != nil {
		return x.MediaType
	}
	return ""
}

func (x *OutputDescriptor) GetSchemaRef() string {
	if x != nil {
		return x.SchemaRef
	}
	return ""
}

func (x *OutputDescriptor) GetStreamed() bool {
	if x != nil {
		return x.Streamed
	}
	return false
}

// Stable identifier for addressing a task capability. Only one of the fields
// is typically needed; receivers match by the most specific provided.
type TaskKey struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`                         // task name, e.g., "ai.analyze"
	Version       string                 `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`                   // semantic version or tag
	StableId      string                 `protobuf:"bytes,3,opt,name=stable_id,json=stableId,proto3" json:"stable_id,omitempty"` // canonical content id if available
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TaskKey) Reset() {
	*x = TaskKey{}
	mi := &file_task_registry_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TaskKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskKey) ProtoMessage() {}

func (x *TaskKey) ProtoReflect() protoreflect.Message {
	mi := &file_task_registry_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskKey.ProtoReflect.Descriptor instead.
func (*TaskKey) Descriptor() ([]byte, []int) {
	return file_task_registry_proto_rawDescGZIP(), []int{2}
}

func (x *TaskKey) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TaskKey) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *TaskKey) GetStableId() string {
	if x != nil {
		return x.StableId
	}
	return ""
}

// Task descriptor advertised by a worker. Mirrors FunctionDesc in spirit but
// remains task-focused and includes optional I/O hints.
type TaskDescriptor struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Human-facing identity
	Name    string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`       // unique task name ("group.action")
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"` // version/tag ("1.2.3" or git sha/tag)
	// Stable implementation identity (identical across identical workers)
	StableId string `protobuf:"bytes,10,opt,name=stable_id,json=stableId,proto3" json:"stable_id,omitempty"` // canonical id (optional)
	HashAlg  string `protobuf:"bytes,11,opt,name=hash_alg,json=hashAlg,proto3" json:"hash_alg,omitempty"`    // e.g., "sha256", "blake3"
	Hash     []byte `protobuf:"bytes,12,opt,name=hash,proto3" json:"hash,omitempty"`                         // digest over canonical package/manifest
	// Capabilities and defaults
	StreamInput     bool         `protobuf:"varint,3,opt,name=stream_input,json=streamInput,proto3" json:"stream_input,omitempty"`             // supports ParamChunk input
	StreamOutput    bool         `protobuf:"varint,4,opt,name=stream_output,json=streamOutput,proto3" json:"stream_output,omitempty"`          // produces streaming Result
	PriorityDefault uint32       `protobuf:"varint,5,opt,name=priority_default,json=priorityDefault,proto3" json:"priority_default,omitempty"` // default priority 0..255
	MinReq          *ResourceReq `protobuf:"bytes,6,opt,name=min_req,json=minReq,proto3" json:"min_req,omitempty"`                             // minimal resource requirements
	MaxConcurrency  uint32       `protobuf:"varint,7,opt,name=max_concurrency,json=maxConcurrency,proto3" json:"max_concurrency,omitempty"`    // worker-local limit (0 = no explicit limit)
	// Optional interface hints
	Contract *IOContract `protobuf:"bytes,20,opt,name=contract,proto3" json:"contract,omitempty"` // advisory inputs/outputs
	// Optional access control policy (per-task). If set and require_signature=true,
	// callers must be signed and present in allowlists.
	Auth *AuthPolicy `protobuf:"bytes,21,opt,name=auth,proto3" json:"auth,omitempty"`
	// Free-form annotations for extensions and routing hints
	Meta          map[string]string `protobuf:"bytes,50,rep,name=meta,proto3" json:"meta,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // e.g., {"lang":"py", "role":"ingest"}
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TaskDescriptor) Reset() {
	*x = TaskDescriptor{}
	mi := &file_task_registry_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TaskDescriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskDescriptor) ProtoMessage() {}

func (x *TaskDescriptor) ProtoReflect() protoreflect.Message {
	mi := &file_task_registry_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskDescriptor.ProtoReflect.Descriptor instead.
func (*TaskDescriptor) Descriptor() ([]byte, []int) {
	return file_task_registry_proto_rawDescGZIP(), []int{3}
}

func (x *TaskDescriptor) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TaskDescriptor) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *TaskDescriptor) GetStableId() string {
	if x != nil {
		return x.StableId
	}
	return ""
}

func (x *TaskDescriptor) GetHashAlg() string {
	if x != nil {
		return x.HashAlg
	}
	return ""
}

func (x *TaskDescriptor) GetHash() []byte {
	if x != nil {
		return x.Hash
	}
	return nil
}

func (x *TaskDescriptor) GetStreamInput() bool {
	if x != nil {
		return x.StreamInput
	}
	return false
}

func (x *TaskDescriptor) GetStreamOutput() bool {
	if x != nil {
		return x.StreamOutput
	}
	return false
}

func (x *TaskDescriptor) GetPriorityDefault() uint32 {
	if x != nil {
		return x.PriorityDefault
	}
	return 0
}

func (x *TaskDescriptor) GetMinReq() *ResourceReq {
	if x != nil {
		return x.MinReq
	}
	return nil
}

func (x *TaskDescriptor) GetMaxConcurrency() uint32 {
	if x != nil {
		return x.MaxConcurrency
	}
	return 0
}

func (x *TaskDescriptor) GetContract() *IOContract {
	if x != nil {
		return x.Contract
	}
	return nil
}

func (x *TaskDescriptor) GetAuth() *AuthPolicy {
	if x != nil {
		return x.Auth
	}
	return nil
}

func (x *TaskDescriptor) GetMeta() map[string]string {
	if x != nil {
		return x.Meta
	}
	return nil
}

// Register a set of task capabilities from a worker with the node.
type TaskRegister struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	WorkerId string                 `protobuf:"bytes,1,opt,name=worker_id,json=workerId,proto3" json:"worker_id,omitempty"` // stable worker identity
	Self     *NodeRef               `protobuf:"bytes,2,opt,name=self,proto3" json:"self,omitempty"`                         // worker node reference
	Tasks    []*TaskDescriptor      `protobuf:"bytes,3,rep,name=tasks,proto3" json:"tasks,omitempty"`                       // capabilities to add/replace
	// Optional: how to reach the worker for direct execution
	Endpoints []*NetworkEndpoint `protobuf:"bytes,4,rep,name=endpoints,proto3" json:"endpoints,omitempty"` // e.g., grpc+tcp, quic, uds
	// Optional: feature flags at the worker level
	Features *FeatureFlags `protobuf:"bytes,5,opt,name=features,proto3" json:"features,omitempty"` // streaming/compression/etc
	// Optional placement/routing labels (region, tier, arch, gpu=...)
	Labels        map[string]string `protobuf:"bytes,6,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TaskRegister) Reset() {
	*x = TaskRegister{}
	mi := &file_task_registry_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TaskRegister) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskRegister) ProtoMessage() {}

func (x *TaskRegister) ProtoReflect() protoreflect.Message {
	mi := &file_task_registry_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskRegister.ProtoReflect.Descriptor instead.
func (*TaskRegister) Descriptor() ([]byte, []int) {
	return file_task_registry_proto_rawDescGZIP(), []int{4}
}

func (x *TaskRegister) GetWorkerId() string {
	if x != nil {
		return x.WorkerId
	}
	return ""
}

func (x *TaskRegister) GetSelf() *NodeRef {
	if x != nil {
		return x.Self
	}
	return nil
}

func (x *TaskRegister) GetTasks() []*TaskDescriptor {
	if x != nil {
		return x.Tasks
	}
	return nil
}

func (x *TaskRegister) GetEndpoints() []*NetworkEndpoint {
	if x != nil {
		return x.Endpoints
	}
	return nil
}

func (x *TaskRegister) GetFeatures() *FeatureFlags {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *TaskRegister) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

// Acknowledgement for registration requests.
type TaskRegisterAck struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Accepted bool                   `protobuf:"varint,1,opt,name=accepted,proto3" json:"accepted,omitempty"` // false when rejected
	Reason   string                 `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`      // human-readable reason
	// Optional: list of task names or stable_ids that conflicted/ignored
	Conflicts     []string `protobuf:"bytes,3,rep,name=conflicts,proto3" json:"conflicts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TaskRegisterAck) Reset() {
	*x = TaskRegisterAck{}
	mi := &file_task_registry_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TaskRegisterAck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskRegisterAck) ProtoMessage() {}

func (x *TaskRegisterAck) ProtoReflect() protoreflect.Message {
	mi := &file_task_registry_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskRegisterAck.ProtoReflect.Descriptor instead.
func (*TaskRegisterAck) Descriptor() ([]byte, []int) {
	return file_task_registry_proto_rawDescGZIP(), []int{5}
}

func (x *TaskRegisterAck) GetAccepted() bool {
	if x != nil {
		return x.Accepted
	}
	return false
}

func (x *TaskRegisterAck) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

func (x *TaskRegisterAck) GetConflicts() []string {
	if x != nil {
		return x.Conflicts
	}
	return nil
}

// Update/delta operations for previously registered tasks.
type TaskUpdate struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	WorkerId    string                 `protobuf:"bytes,1,opt,name=worker_id,json=workerId,proto3" json:"worker_id,omitempty"`
	AddOrUpdate []*TaskDescriptor      `protobuf:"bytes,2,rep,name=add_or_update,json=addOrUpdate,proto3" json:"add_or_update,omitempty"` // upsert by (stable_id|name+version)
	Remove      []*TaskKey             `protobuf:"bytes,3,rep,name=remove,proto3" json:"remove,omitempty"`                                // remove by key
	// Optional worker-level changes (deltas)
	Endpoints     []*NetworkEndpoint `protobuf:"bytes,4,rep,name=endpoints,proto3" json:"endpoints,omitempty"`                                                                                            // replace if set (idempotent)
	LabelsSet     map[string]string  `protobuf:"bytes,5,rep,name=labels_set,json=labelsSet,proto3" json:"labels_set,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // set/update labels
	LabelsDel     []string           `protobuf:"bytes,6,rep,name=labels_del,json=labelsDel,proto3" json:"labels_del,omitempty"`                                                                           // delete label keys
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TaskUpdate) Reset() {
	*x = TaskUpdate{}
	mi := &file_task_registry_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TaskUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskUpdate) ProtoMessage() {}

func (x *TaskUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_task_registry_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskUpdate.ProtoReflect.Descriptor instead.
func (*TaskUpdate) Descriptor() ([]byte, []int) {
	return file_task_registry_proto_rawDescGZIP(), []int{6}
}

func (x *TaskUpdate) GetWorkerId() string {
	if x != nil {
		return x.WorkerId
	}
	return ""
}

func (x *TaskUpdate) GetAddOrUpdate() []*TaskDescriptor {
	if x != nil {
		return x.AddOrUpdate
	}
	return nil
}

func (x *TaskUpdate) GetRemove() []*TaskKey {
	if x != nil {
		return x.Remove
	}
	return nil
}

func (x *TaskUpdate) GetEndpoints() []*NetworkEndpoint {
	if x != nil {
		return x.Endpoints
	}
	return nil
}

func (x *TaskUpdate) GetLabelsSet() map[string]string {
	if x != nil {
		return x.LabelsSet
	}
	return nil
}

func (x *TaskUpdate) GetLabelsDel() []string {
	if x != nil {
		return x.LabelsDel
	}
	return nil
}

// Explicit deregistration for a worker or specific tasks.
type TaskDeregister struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	WorkerId      string                 `protobuf:"bytes,1,opt,name=worker_id,json=workerId,proto3" json:"worker_id,omitempty"` // required
	Tasks         []*TaskKey             `protobuf:"bytes,2,rep,name=tasks,proto3" json:"tasks,omitempty"`                       // empty = deregister all
	Reason        string                 `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`                     // optional reason
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TaskDeregister) Reset() {
	*x = TaskDeregister{}
	mi := &file_task_registry_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TaskDeregister) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskDeregister) ProtoMessage() {}

func (x *TaskDeregister) ProtoReflect() protoreflect.Message {
	mi := &file_task_registry_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskDeregister.ProtoReflect.Descriptor instead.
func (*TaskDeregister) Descriptor() ([]byte, []int) {
	return file_task_registry_proto_rawDescGZIP(), []int{7}
}

func (x *TaskDeregister) GetWorkerId() string {
	if x != nil {
		return x.WorkerId
	}
	return ""
}

func (x *TaskDeregister) GetTasks() []*TaskKey {
	if x != nil {
		return x.Tasks
	}
	return nil
}

func (x *TaskDeregister) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

// List registered workers (with optional filtering and pagination)
type TaskListWorkers struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional label filter: match workers whose labels are a superset of these.
	LabelFilter map[string]string `protobuf:"bytes,1,rep,name=label_filter,json=labelFilter,proto3" json:"label_filter,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Optional capability filter
	FunctionName string `protobuf:"bytes,2,opt,name=function_name,json=functionName,proto3" json:"function_name,omitempty"` // filter workers that advertise this task name
	Version      string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`                               // optional semver/tag selector
	// Include per-worker task descriptors in response (may be large)
	IncludeTasks bool `protobuf:"varint,4,opt,name=include_tasks,json=includeTasks,proto3" json:"include_tasks,omitempty"`
	// Pagination (optional)
	PageSize      uint32 `protobuf:"varint,5,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`   // 0 = default, max enforced by server
	PageToken     string `protobuf:"bytes,6,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"` // returned from previous reply
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TaskListWorkers) Reset() {
	*x = TaskListWorkers{}
	mi := &file_task_registry_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TaskListWorkers) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskListWorkers) ProtoMessage() {}

func (x *TaskListWorkers) ProtoReflect() protoreflect.Message {
	mi := &file_task_registry_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskListWorkers.ProtoReflect.Descriptor instead.
func (*TaskListWorkers) Descriptor() ([]byte, []int) {
	return file_task_registry_proto_rawDescGZIP(), []int{8}
}

func (x *TaskListWorkers) GetLabelFilter() map[string]string {
	if x != nil {
		return x.LabelFilter
	}
	return nil
}

func (x *TaskListWorkers) GetFunctionName() string {
	if x != nil {
		return x.FunctionName
	}
	return ""
}

func (x *TaskListWorkers) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *TaskListWorkers) GetIncludeTasks() bool {
	if x != nil {
		return x.IncludeTasks
	}
	return false
}

func (x *TaskListWorkers) GetPageSize() uint32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *TaskListWorkers) GetPageToken() string {
	if x != nil {
		return x.PageToken
	}
	return ""
}

type WorkerRecord struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	WorkerId      string                 `protobuf:"bytes,1,opt,name=worker_id,json=workerId,proto3" json:"worker_id,omitempty"`
	Self          *NodeRef               `protobuf:"bytes,2,opt,name=self,proto3" json:"self,omitempty"`
	Endpoints     []*NetworkEndpoint     `protobuf:"bytes,3,rep,name=endpoints,proto3" json:"endpoints,omitempty"`
	Features      *FeatureFlags          `protobuf:"bytes,4,opt,name=features,proto3" json:"features,omitempty"`
	Labels        map[string]string      `protobuf:"bytes,5,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	CapacityTotal *ResourceCapacity      `protobuf:"bytes,6,opt,name=capacity_total,json=capacityTotal,proto3" json:"capacity_total,omitempty"`
	CapacityFree  *ResourceCapacity      `protobuf:"bytes,7,opt,name=capacity_free,json=capacityFree,proto3" json:"capacity_free,omitempty"`
	Tasks         []*TaskDescriptor      `protobuf:"bytes,8,rep,name=tasks,proto3" json:"tasks,omitempty"` // present if include_tasks=true
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorkerRecord) Reset() {
	*x = WorkerRecord{}
	mi := &file_task_registry_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkerRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkerRecord) ProtoMessage() {}

func (x *WorkerRecord) ProtoReflect() protoreflect.Message {
	mi := &file_task_registry_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkerRecord.ProtoReflect.Descriptor instead.
func (*WorkerRecord) Descriptor() ([]byte, []int) {
	return file_task_registry_proto_rawDescGZIP(), []int{9}
}

func (x *WorkerRecord) GetWorkerId() string {
	if x != nil {
		return x.WorkerId
	}
	return ""
}

func (x *WorkerRecord) GetSelf() *NodeRef {
	if x != nil {
		return x.Self
	}
	return nil
}

func (x *WorkerRecord) GetEndpoints() []*NetworkEndpoint {
	if x != nil {
		return x.Endpoints
	}
	return nil
}

func (x *WorkerRecord) GetFeatures() *FeatureFlags {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *WorkerRecord) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *WorkerRecord) GetCapacityTotal() *ResourceCapacity {
	if x != nil {
		return x.CapacityTotal
	}
	return nil
}

func (x *WorkerRecord) GetCapacityFree() *ResourceCapacity {
	if x != nil {
		return x.CapacityFree
	}
	return nil
}

func (x *WorkerRecord) GetTasks() []*TaskDescriptor {
	if x != nil {
		return x.Tasks
	}
	return nil
}

type TaskListWorkersReply struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Workers       []*WorkerRecord        `protobuf:"bytes,1,rep,name=workers,proto3" json:"workers,omitempty"`
	NextPageToken string                 `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TaskListWorkersReply) Reset() {
	*x = TaskListWorkersReply{}
	mi := &file_task_registry_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TaskListWorkersReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskListWorkersReply) ProtoMessage() {}

func (x *TaskListWorkersReply) ProtoReflect() protoreflect.Message {
	mi := &file_task_registry_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskListWorkersReply.ProtoReflect.Descriptor instead.
func (*TaskListWorkersReply) Descriptor() ([]byte, []int) {
	return file_task_registry_proto_rawDescGZIP(), []int{10}
}

func (x *TaskListWorkersReply) GetWorkers() []*WorkerRecord {
	if x != nil {
		return x.Workers
	}
	return nil
}

func (x *TaskListWorkersReply) GetNextPageToken() string {
	if x != nil {
		return x.NextPageToken
	}
	return ""
}

var File_task_registry_proto protoreflect.FileDescriptor

const file_task_registry_proto_rawDesc = "" +
	"\n" +
	"\x13task_registry.proto\x12\fttmesh.proto\x1a\fcommon.proto\x1a\n" +
	"task.proto\x1a\fworker.proto\"}\n" +
	"\n" +
	"IOContract\x125\n" +
	"\x06inputs\x18\x01 \x03(\v2\x1d.ttmesh.proto.ParamDescriptorR\x06inputs\x128\n" +
	"\aoutputs\x18\x02 \x03(\v2\x1e.ttmesh.proto.OutputDescriptorR\aoutputs\"\x80\x01\n" +
	"\x10OutputDescriptor\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1d\n" +
	"\n" +
	"media_type\x18\x02 \x01(\tR\tmediaType\x12\x1d\n" +
	"\n" +
	"schema_ref\x18\x03 \x01(\tR\tschemaRef\x12\x1a\n" +
	"\bstreamed\x18\x04 \x01(\bR\bstreamed\"T\n" +
	"\aTaskKey\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12\x1b\n" +
	"\tstable_id\x18\x03 \x01(\tR\bstableId\"\xb3\x04\n" +
	"\x0eTaskDescriptor\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12\x1b\n" +
	"\tstable_id\x18\n" +
	" \x01(\tR\bstableId\x12\x19\n" +
	"\bhash_alg\x18\v \x01(\tR\ahashAlg\x12\x12\n" +
	"\x04hash\x18\f \x01(\fR\x04hash\x12!\n" +
	"\fstream_input\x18\x03 \x01(\bR\vstreamInput\x12#\n" +
	"\rstream_output\x18\x04 \x01(\bR\fstreamOutput\x12)\n" +
	"\x10priority_default\x18\x05 \x01(\rR\x0fpriorityDefault\x122\n" +
	"\amin_req\x18\x06 \x01(\v2\x19.ttmesh.proto.ResourceReqR\x06minReq\x12'\n" +
	"\x0fmax_concurrency\x18\a \x01(\rR\x0emaxConcurrency\x124\n" +
	"\bcontract\x18\x14 \x01(\v2\x18.ttmesh.proto.IOContractR\bcontract\x12,\n" +
	"\x04auth\x18\x15 \x01(\v2\x18.ttmesh.proto.AuthPolicyR\x04auth\x12:\n" +
	"\x04meta\x182 \x03(\v2&.ttmesh.proto.TaskDescriptor.MetaEntryR\x04meta\x1a7\n" +
	"\tMetaEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xfa\x02\n" +
	"\fTaskRegister\x12\x1b\n" +
	"\tworker_id\x18\x01 \x01(\tR\bworkerId\x12)\n" +
	"\x04self\x18\x02 \x01(\v2\x15.ttmesh.proto.NodeRefR\x04self\x122\n" +
	"\x05tasks\x18\x03 \x03(\v2\x1c.ttmesh.proto.TaskDescriptorR\x05tasks\x12;\n" +
	"\tendpoints\x18\x04 \x03(\v2\x1d.ttmesh.proto.NetworkEndpointR\tendpoints\x126\n" +
	"\bfeatures\x18\x05 \x01(\v2\x1a.ttmesh.proto.FeatureFlagsR\bfeatures\x12>\n" +
	"\x06labels\x18\x06 \x03(\v2&.ttmesh.proto.TaskRegister.LabelsEntryR\x06labels\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"c\n" +
	"\x0fTaskRegisterAck\x12\x1a\n" +
	"\baccepted\x18\x01 \x01(\bR\baccepted\x12\x16\n" +
	"\x06reason\x18\x02 \x01(\tR\x06reason\x12\x1c\n" +
	"\tconflicts\x18\x03 \x03(\tR\tconflicts\"\xfc\x02\n" +
	"\n" +
	"TaskUpdate\x12\x1b\n" +
	"\tworker_id\x18\x01 \x01(\tR\bworkerId\x12@\n" +
	"\radd_or_update\x18\x02 \x03(\v2\x1c.ttmesh.proto.TaskDescriptorR\vaddOrUpdate\x12-\n" +
	"\x06remove\x18\x03 \x03(\v2\x15.ttmesh.proto.TaskKeyR\x06remove\x12;\n" +
	"\tendpoints\x18\x04 \x03(\v2\x1d.ttmesh.proto.NetworkEndpointR\tendpoints\x12F\n" +
	"\n" +
	"labels_set\x18\x05 \x03(\v2'.ttmesh.proto.TaskUpdate.LabelsSetEntryR\tlabelsSet\x12\x1d\n" +
	"\n" +
	"labels_del\x18\x06 \x03(\tR\tlabelsDel\x1a<\n" +
	"\x0eLabelsSetEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"r\n" +
	"\x0eTaskDeregister\x12\x1b\n" +
	"\tworker_id\x18\x01 \x01(\tR\bworkerId\x12+\n" +
	"\x05tasks\x18\x02 \x03(\v2\x15.ttmesh.proto.TaskKeyR\x05tasks\x12\x16\n" +
	"\x06reason\x18\x03 \x01(\tR\x06reason\"\xc4\x02\n" +
	"\x0fTaskListWorkers\x12Q\n" +
	"\flabel_filter\x18\x01 \x03(\v2..ttmesh.proto.TaskListWorkers.LabelFilterEntryR\vlabelFilter\x12#\n" +
	"\rfunction_name\x18\x02 \x01(\tR\ffunctionName\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x12#\n" +
	"\rinclude_tasks\x18\x04 \x01(\bR\fincludeTasks\x12\x1b\n" +
	"\tpage_size\x18\x05 \x01(\rR\bpageSize\x12\x1d\n" +
	"\n" +
	"page_token\x18\x06 \x01(\tR\tpageToken\x1a>\n" +
	"\x10LabelFilterEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x86\x04\n" +
	"\fWorkerRecord\x12\x1b\n" +
	"\tworker_id\x18\x01 \x01(\tR\bworkerId\x12)\n" +
	"\x04self\x18\x02 \x01(\v2\x15.ttmesh.proto.NodeRefR\x04self\x12;\n" +
	"\tendpoints\x18\x03 \x03(\v2\x1d.ttmesh.proto.NetworkEndpointR\tendpoints\x126\n" +
	"\bfeatures\x18\x04 \x01(\v2\x1a.ttmesh.proto.FeatureFlagsR\bfeatures\x12>\n" +
	"\x06labels\x18\x05 \x03(\v2&.ttmesh.proto.WorkerRecord.LabelsEntryR\x06labels\x12E\n" +
	"\x0ecapacity_total\x18\x06 \x01(\v2\x1e.ttmesh.proto.ResourceCapacityR\rcapacityTotal\x12C\n" +
	"\rcapacity_free\x18\a \x01(\v2\x1e.ttmesh.proto.ResourceCapacityR\fcapacityFree\x122\n" +
	"\x05tasks\x18\b \x03(\v2\x1c.ttmesh.proto.TaskDescriptorR\x05tasks\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"t\n" +
	"\x14TaskListWorkersReply\x124\n" +
	"\aworkers\x18\x01 \x03(\v2\x1a.ttmesh.proto.WorkerRecordR\aworkers\x12&\n" +
	"\x0fnext_page_token\x18\x02 \x01(\tR\rnextPageTokenB'Z%ttmesh/pkg/protocol/proto;ttmeshprotob\x06proto3"

var (
	file_task_registry_proto_rawDescOnce sync.Once
	file_task_registry_proto_rawDescData []byte
)

func file_task_registry_proto_rawDescGZIP() []byte {
	file_task_registry_proto_rawDescOnce.Do(func() {
		file_task_registry_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_task_registry_proto_rawDesc), len(file_task_registry_proto_rawDesc)))
	})
	return file_task_registry_proto_rawDescData
}

var file_task_registry_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_task_registry_proto_goTypes = []any{
	(*IOContract)(nil),           // 0: ttmesh.proto.IOContract
	(*OutputDescriptor)(nil),     // 1: ttmesh.proto.OutputDescriptor
	(*TaskKey)(nil),              // 2: ttmesh.proto.TaskKey
	(*TaskDescriptor)(nil),       // 3: ttmesh.proto.TaskDescriptor
	(*TaskRegister)(nil),         // 4: ttmesh.proto.TaskRegister
	(*TaskRegisterAck)(nil),      // 5: ttmesh.proto.TaskRegisterAck
	(*TaskUpdate)(nil),           // 6: ttmesh.proto.TaskUpdate
	(*TaskDeregister)(nil),       // 7: ttmesh.proto.TaskDeregister
	(*TaskListWorkers)(nil),      // 8: ttmesh.proto.TaskListWorkers
	(*WorkerRecord)(nil),         // 9: ttmesh.proto.WorkerRecord
	(*TaskListWorkersReply)(nil), // 10: ttmesh.proto.TaskListWorkersReply
	nil,                          // 11: ttmesh.proto.TaskDescriptor.MetaEntry
	nil,                          // 12: ttmesh.proto.TaskRegister.LabelsEntry
	nil,                          // 13: ttmesh.proto.TaskUpdate.LabelsSetEntry
	nil,                          // 14: ttmesh.proto.TaskListWorkers.LabelFilterEntry
	nil,                          // 15: ttmesh.proto.WorkerRecord.LabelsEntry
	(*ParamDescriptor)(nil),      // 16: ttmesh.proto.ParamDescriptor
	(*ResourceReq)(nil),          // 17: ttmesh.proto.ResourceReq
	(*AuthPolicy)(nil),           // 18: ttmesh.proto.AuthPolicy
	(*NodeRef)(nil),              // 19: ttmesh.proto.NodeRef
	(*NetworkEndpoint)(nil),      // 20: ttmesh.proto.NetworkEndpoint
	(*FeatureFlags)(nil),         // 21: ttmesh.proto.FeatureFlags
	(*ResourceCapacity)(nil),     // 22: ttmesh.proto.ResourceCapacity
}
var file_task_registry_proto_depIdxs = []int32{
	16, // 0: ttmesh.proto.IOContract.inputs:type_name -> ttmesh.proto.ParamDescriptor
	1,  // 1: ttmesh.proto.IOContract.outputs:type_name -> ttmesh.proto.OutputDescriptor
	17, // 2: ttmesh.proto.TaskDescriptor.min_req:type_name -> ttmesh.proto.ResourceReq
	0,  // 3: ttmesh.proto.TaskDescriptor.contract:type_name -> ttmesh.proto.IOContract
	18, // 4: ttmesh.proto.TaskDescriptor.auth:type_name -> ttmesh.proto.AuthPolicy
	11, // 5: ttmesh.proto.TaskDescriptor.meta:type_name -> ttmesh.proto.TaskDescriptor.MetaEntry
	19, // 6: ttmesh.proto.TaskRegister.self:type_name -> ttmesh.proto.NodeRef
	3,  // 7: ttmesh.proto.TaskRegister.tasks:type_name -> ttmesh.proto.TaskDescriptor
	20, // 8: ttmesh.proto.TaskRegister.endpoints:type_name -> ttmesh.proto.NetworkEndpoint
	21, // 9: ttmesh.proto.TaskRegister.features:type_name -> ttmesh.proto.FeatureFlags
	12, // 10: ttmesh.proto.TaskRegister.labels:type_name -> ttmesh.proto.TaskRegister.LabelsEntry
	3,  // 11: ttmesh.proto.TaskUpdate.add_or_update:type_name -> ttmesh.proto.TaskDescriptor
	2,  // 12: ttmesh.proto.TaskUpdate.remove:type_name -> ttmesh.proto.TaskKey
	20, // 13: ttmesh.proto.TaskUpdate.endpoints:type_name -> ttmesh.proto.NetworkEndpoint
	13, // 14: ttmesh.proto.TaskUpdate.labels_set:type_name -> ttmesh.proto.TaskUpdate.LabelsSetEntry
	2,  // 15: ttmesh.proto.TaskDeregister.tasks:type_name -> ttmesh.proto.TaskKey
	14, // 16: ttmesh.proto.TaskListWorkers.label_filter:type_name -> ttmesh.proto.TaskListWorkers.LabelFilterEntry
	19, // 17: ttmesh.proto.WorkerRecord.self:type_name -> ttmesh.proto.NodeRef
	20, // 18: ttmesh.proto.WorkerRecord.endpoints:type_name -> ttmesh.proto.NetworkEndpoint
	21, // 19: ttmesh.proto.WorkerRecord.features:type_name -> ttmesh.proto.FeatureFlags
	15, // 20: ttmesh.proto.WorkerRecord.labels:type_name -> ttmesh.proto.WorkerRecord.LabelsEntry
	22, // 21: ttmesh.proto.WorkerRecord.capacity_total:type_name -> ttmesh.proto.ResourceCapacity
	22, // 22: ttmesh.proto.WorkerRecord.capacity_free:type_name -> ttmesh.proto.ResourceCapacity
	3,  // 23: ttmesh.proto.WorkerRecord.tasks:type_name -> ttmesh.proto.TaskDescriptor
	9,  // 24: ttmesh.proto.TaskListWorkersReply.workers:type_name -> ttmesh.proto.WorkerRecord
	25, // [25:25] is the sub-list for method output_type
	25, // [25:25] is the sub-list for method input_type
	25, // [25:25] is the sub-list for extension type_name
	25, // [25:25] is the sub-list for extension extendee
	0,  // [0:25] is the sub-list for field type_name
}

func init() { file_task_registry_proto_init() }
func file_task_registry_proto_init() {
	if File_task_registry_proto != nil {
		return
	}
	file_common_proto_init()
	file_task_proto_init()
	file_worker_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_task_registry_proto_rawDesc), len(file_task_registry_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_task_registry_proto_goTypes,
		DependencyIndexes: file_task_registry_proto_depIdxs,
		MessageInfos:      file_task_registry_proto_msgTypes,
	}.Build()
	File_task_registry_proto = out.File
	file_task_registry_proto_goTypes = nil
	file_task_registry_proto_depIdxs = nil
}
