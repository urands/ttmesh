// proto definitions for ttmesh (optional gRPC layer)

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        v6.32.0
// source: ttmesh.proto

package ttmeshproto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Fixed-style header carried in gRPC representation
type Header struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Version       uint32                 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`                                                                     // protocol version
	Type          MessageType            `protobuf:"varint,2,opt,name=type,proto3,enum=ttmesh.proto.MessageType" json:"type,omitempty"`                                             // message kind
	Flags         uint32                 `protobuf:"varint,3,opt,name=flags,proto3" json:"flags,omitempty"`                                                                         // bitmask flags
	Priority      uint32                 `protobuf:"varint,4,opt,name=priority,proto3" json:"priority,omitempty"`                                                                   // 0..255
	CorrelationId []byte                 `protobuf:"bytes,5,opt,name=correlation_id,json=correlationId,proto3" json:"correlation_id,omitempty"`                                     // 16 bytes UUID-like id
	Source        *NodeRef               `protobuf:"bytes,6,opt,name=source,proto3" json:"source,omitempty"`                                                                        // source node
	Dest          *NodeRef               `protobuf:"bytes,7,opt,name=dest,proto3" json:"dest,omitempty"`                                                                            // destination node (transport-level)
	ReplyTo       *NodeRef               `protobuf:"bytes,8,opt,name=reply_to,json=replyTo,proto3" json:"reply_to,omitempty"`                                                       // where to send final result
	FragIndex     uint32                 `protobuf:"varint,9,opt,name=frag_index,json=fragIndex,proto3" json:"frag_index,omitempty"`                                                // fragment index (optional)
	FragTotal     uint32                 `protobuf:"varint,10,opt,name=frag_total,json=fragTotal,proto3" json:"frag_total,omitempty"`                                               // total fragments (optional)
	MessageId     []byte                 `protobuf:"bytes,11,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`                                                // message id (ULID/UUID)
	TraceId       []byte                 `protobuf:"bytes,12,opt,name=trace_id,json=traceId,proto3" json:"trace_id,omitempty"`                                                      // tracing id (optional)
	CreatedUnixMs int64                  `protobuf:"varint,13,opt,name=created_unix_ms,json=createdUnixMs,proto3" json:"created_unix_ms,omitempty"`                                 // creation time
	Tags          map[string]string      `protobuf:"bytes,14,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // arbitrary tags
	Codec         Codec                  `protobuf:"varint,15,opt,name=codec,proto3,enum=ttmesh.proto.Codec" json:"codec,omitempty"`                                                // payload codec hint
	Compression   Compression            `protobuf:"varint,16,opt,name=compression,proto3,enum=ttmesh.proto.Compression" json:"compression,omitempty"`                              // payload compression hint
	// Direct peer processing result (simple OK/NOT OK) sent back
	// as a lightweight immediate response between directly connected peers.
	// This is distinct from worker-level Ack/Nack and is set by the receiver
	// after the envelope is processed in its local queue.
	DirectStatus  *Status `protobuf:"varint,17,opt,name=direct_status,json=directStatus,proto3,enum=ttmesh.proto.Status,oneof" json:"direct_status,omitempty"` // ST_OK or ST_FAILED when present
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Header) Reset() {
	*x = Header{}
	mi := &file_ttmesh_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Header) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Header) ProtoMessage() {}

func (x *Header) ProtoReflect() protoreflect.Message {
	mi := &file_ttmesh_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Header.ProtoReflect.Descriptor instead.
func (*Header) Descriptor() ([]byte, []int) {
	return file_ttmesh_proto_rawDescGZIP(), []int{0}
}

func (x *Header) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *Header) GetType() MessageType {
	if x != nil {
		return x.Type
	}
	return MessageType_MT_UNKNOWN
}

func (x *Header) GetFlags() uint32 {
	if x != nil {
		return x.Flags
	}
	return 0
}

func (x *Header) GetPriority() uint32 {
	if x != nil {
		return x.Priority
	}
	return 0
}

func (x *Header) GetCorrelationId() []byte {
	if x != nil {
		return x.CorrelationId
	}
	return nil
}

func (x *Header) GetSource() *NodeRef {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *Header) GetDest() *NodeRef {
	if x != nil {
		return x.Dest
	}
	return nil
}

func (x *Header) GetReplyTo() *NodeRef {
	if x != nil {
		return x.ReplyTo
	}
	return nil
}

func (x *Header) GetFragIndex() uint32 {
	if x != nil {
		return x.FragIndex
	}
	return 0
}

func (x *Header) GetFragTotal() uint32 {
	if x != nil {
		return x.FragTotal
	}
	return 0
}

func (x *Header) GetMessageId() []byte {
	if x != nil {
		return x.MessageId
	}
	return nil
}

func (x *Header) GetTraceId() []byte {
	if x != nil {
		return x.TraceId
	}
	return nil
}

func (x *Header) GetCreatedUnixMs() int64 {
	if x != nil {
		return x.CreatedUnixMs
	}
	return 0
}

func (x *Header) GetTags() map[string]string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *Header) GetCodec() Codec {
	if x != nil {
		return x.Codec
	}
	return Codec_CODEC_RAW
}

func (x *Header) GetCompression() Compression {
	if x != nil {
		return x.Compression
	}
	return Compression_COMP_NONE
}

func (x *Header) GetDirectStatus() Status {
	if x != nil && x.DirectStatus != nil {
		return *x.DirectStatus
	}
	return Status_ST_OK
}

// Envelope is a structured container for both control and task data.
// It carries routing cursors (step_id/next_step), hop breadcrumbs and oneof body.
type Envelope struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Header *Header                `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Meta   *Metadata              `protobuf:"bytes,2,opt,name=meta,proto3" json:"meta,omitempty"` // workflow/routing cursor
	Hops   []*HopMeta             `protobuf:"bytes,3,rep,name=hops,proto3" json:"hops,omitempty"` // last N routing decisions
	Bus    *BusHeader             `protobuf:"bytes,4,opt,name=bus,proto3" json:"bus,omitempty"`   // minimal bus header (optional)
	// Types that are valid to be assigned to Body:
	//
	//	*Envelope_Invoke
	//	*Envelope_Chunk
	//	*Envelope_Result
	//	*Envelope_Ack
	//	*Envelope_Control
	//	*Envelope_LeaseReq
	//	*Envelope_LeaseRep
	//	*Envelope_Raw
	//	*Envelope_TinyResult
	//	*Envelope_SessionInit
	//	*Envelope_SessionClose
	Body          isEnvelope_Body `protobuf_oneof:"body"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Envelope) Reset() {
	*x = Envelope{}
	mi := &file_ttmesh_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Envelope) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Envelope) ProtoMessage() {}

func (x *Envelope) ProtoReflect() protoreflect.Message {
	mi := &file_ttmesh_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Envelope.ProtoReflect.Descriptor instead.
func (*Envelope) Descriptor() ([]byte, []int) {
	return file_ttmesh_proto_rawDescGZIP(), []int{1}
}

func (x *Envelope) GetHeader() *Header {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *Envelope) GetMeta() *Metadata {
	if x != nil {
		return x.Meta
	}
	return nil
}

func (x *Envelope) GetHops() []*HopMeta {
	if x != nil {
		return x.Hops
	}
	return nil
}

func (x *Envelope) GetBus() *BusHeader {
	if x != nil {
		return x.Bus
	}
	return nil
}

func (x *Envelope) GetBody() isEnvelope_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *Envelope) GetInvoke() *Invoke {
	if x != nil {
		if x, ok := x.Body.(*Envelope_Invoke); ok {
			return x.Invoke
		}
	}
	return nil
}

func (x *Envelope) GetChunk() *ParamChunk {
	if x != nil {
		if x, ok := x.Body.(*Envelope_Chunk); ok {
			return x.Chunk
		}
	}
	return nil
}

func (x *Envelope) GetResult() *Result {
	if x != nil {
		if x, ok := x.Body.(*Envelope_Result); ok {
			return x.Result
		}
	}
	return nil
}

func (x *Envelope) GetAck() *Ack {
	if x != nil {
		if x, ok := x.Body.(*Envelope_Ack); ok {
			return x.Ack
		}
	}
	return nil
}

func (x *Envelope) GetControl() *Control {
	if x != nil {
		if x, ok := x.Body.(*Envelope_Control); ok {
			return x.Control
		}
	}
	return nil
}

func (x *Envelope) GetLeaseReq() *LeaseRequest {
	if x != nil {
		if x, ok := x.Body.(*Envelope_LeaseReq); ok {
			return x.LeaseReq
		}
	}
	return nil
}

func (x *Envelope) GetLeaseRep() *LeaseReply {
	if x != nil {
		if x, ok := x.Body.(*Envelope_LeaseRep); ok {
			return x.LeaseRep
		}
	}
	return nil
}

func (x *Envelope) GetRaw() []byte {
	if x != nil {
		if x, ok := x.Body.(*Envelope_Raw); ok {
			return x.Raw
		}
	}
	return nil
}

func (x *Envelope) GetTinyResult() *TinyResult {
	if x != nil {
		if x, ok := x.Body.(*Envelope_TinyResult); ok {
			return x.TinyResult
		}
	}
	return nil
}

func (x *Envelope) GetSessionInit() *SessionInit {
	if x != nil {
		if x, ok := x.Body.(*Envelope_SessionInit); ok {
			return x.SessionInit
		}
	}
	return nil
}

func (x *Envelope) GetSessionClose() *SessionClose {
	if x != nil {
		if x, ok := x.Body.(*Envelope_SessionClose); ok {
			return x.SessionClose
		}
	}
	return nil
}

type isEnvelope_Body interface {
	isEnvelope_Body()
}

type Envelope_Invoke struct {
	Invoke *Invoke `protobuf:"bytes,10,opt,name=invoke,proto3,oneof"`
}

type Envelope_Chunk struct {
	Chunk *ParamChunk `protobuf:"bytes,11,opt,name=chunk,proto3,oneof"`
}

type Envelope_Result struct {
	Result *Result `protobuf:"bytes,12,opt,name=result,proto3,oneof"`
}

type Envelope_Ack struct {
	Ack *Ack `protobuf:"bytes,13,opt,name=ack,proto3,oneof"`
}

type Envelope_Control struct {
	Control *Control `protobuf:"bytes,14,opt,name=control,proto3,oneof"`
}

type Envelope_LeaseReq struct {
	LeaseReq *LeaseRequest `protobuf:"bytes,15,opt,name=lease_req,json=leaseReq,proto3,oneof"`
}

type Envelope_LeaseRep struct {
	LeaseRep *LeaseReply `protobuf:"bytes,16,opt,name=lease_rep,json=leaseRep,proto3,oneof"`
}

type Envelope_Raw struct {
	Raw []byte `protobuf:"bytes,17,opt,name=raw,proto3,oneof"` // fallback opaque payload
}

type Envelope_TinyResult struct {
	TinyResult *TinyResult `protobuf:"bytes,18,opt,name=tiny_result,json=tinyResult,proto3,oneof"` // compact response form
}

type Envelope_SessionInit struct {
	SessionInit *SessionInit `protobuf:"bytes,19,opt,name=session_init,json=sessionInit,proto3,oneof"` // cache baseline context on receiver
}

type Envelope_SessionClose struct {
	SessionClose *SessionClose `protobuf:"bytes,20,opt,name=session_close,json=sessionClose,proto3,oneof"` // drop cached context
}

func (*Envelope_Invoke) isEnvelope_Body() {}

func (*Envelope_Chunk) isEnvelope_Body() {}

func (*Envelope_Result) isEnvelope_Body() {}

func (*Envelope_Ack) isEnvelope_Body() {}

func (*Envelope_Control) isEnvelope_Body() {}

func (*Envelope_LeaseReq) isEnvelope_Body() {}

func (*Envelope_LeaseRep) isEnvelope_Body() {}

func (*Envelope_Raw) isEnvelope_Body() {}

func (*Envelope_TinyResult) isEnvelope_Body() {}

func (*Envelope_SessionInit) isEnvelope_Body() {}

func (*Envelope_SessionClose) isEnvelope_Body() {}

var File_ttmesh_proto protoreflect.FileDescriptor

const file_ttmesh_proto_rawDesc = "" +
	"\n" +
	"\fttmesh.proto\x12\fttmesh.proto\x1a\fcommon.proto\x1a\rrouting.proto\x1a\n" +
	"task.proto\x1a\rcontrol.proto\x1a\n" +
	"tiny.proto\"\xfd\x05\n" +
	"\x06Header\x12\x18\n" +
	"\aversion\x18\x01 \x01(\rR\aversion\x12-\n" +
	"\x04type\x18\x02 \x01(\x0e2\x19.ttmesh.proto.MessageTypeR\x04type\x12\x14\n" +
	"\x05flags\x18\x03 \x01(\rR\x05flags\x12\x1a\n" +
	"\bpriority\x18\x04 \x01(\rR\bpriority\x12%\n" +
	"\x0ecorrelation_id\x18\x05 \x01(\fR\rcorrelationId\x12-\n" +
	"\x06source\x18\x06 \x01(\v2\x15.ttmesh.proto.NodeRefR\x06source\x12)\n" +
	"\x04dest\x18\a \x01(\v2\x15.ttmesh.proto.NodeRefR\x04dest\x120\n" +
	"\breply_to\x18\b \x01(\v2\x15.ttmesh.proto.NodeRefR\areplyTo\x12\x1d\n" +
	"\n" +
	"frag_index\x18\t \x01(\rR\tfragIndex\x12\x1d\n" +
	"\n" +
	"frag_total\x18\n" +
	" \x01(\rR\tfragTotal\x12\x1d\n" +
	"\n" +
	"message_id\x18\v \x01(\fR\tmessageId\x12\x19\n" +
	"\btrace_id\x18\f \x01(\fR\atraceId\x12&\n" +
	"\x0fcreated_unix_ms\x18\r \x01(\x03R\rcreatedUnixMs\x122\n" +
	"\x04tags\x18\x0e \x03(\v2\x1e.ttmesh.proto.Header.TagsEntryR\x04tags\x12)\n" +
	"\x05codec\x18\x0f \x01(\x0e2\x13.ttmesh.proto.CodecR\x05codec\x12;\n" +
	"\vcompression\x18\x10 \x01(\x0e2\x19.ttmesh.proto.CompressionR\vcompression\x12>\n" +
	"\rdirect_status\x18\x11 \x01(\x0e2\x14.ttmesh.proto.StatusH\x00R\fdirectStatus\x88\x01\x01\x1a7\n" +
	"\tTagsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\x10\n" +
	"\x0e_direct_status\"\xf6\x05\n" +
	"\bEnvelope\x12,\n" +
	"\x06header\x18\x01 \x01(\v2\x14.ttmesh.proto.HeaderR\x06header\x12*\n" +
	"\x04meta\x18\x02 \x01(\v2\x16.ttmesh.proto.MetadataR\x04meta\x12)\n" +
	"\x04hops\x18\x03 \x03(\v2\x15.ttmesh.proto.HopMetaR\x04hops\x12)\n" +
	"\x03bus\x18\x04 \x01(\v2\x17.ttmesh.proto.BusHeaderR\x03bus\x12.\n" +
	"\x06invoke\x18\n" +
	" \x01(\v2\x14.ttmesh.proto.InvokeH\x00R\x06invoke\x120\n" +
	"\x05chunk\x18\v \x01(\v2\x18.ttmesh.proto.ParamChunkH\x00R\x05chunk\x12.\n" +
	"\x06result\x18\f \x01(\v2\x14.ttmesh.proto.ResultH\x00R\x06result\x12%\n" +
	"\x03ack\x18\r \x01(\v2\x11.ttmesh.proto.AckH\x00R\x03ack\x121\n" +
	"\acontrol\x18\x0e \x01(\v2\x15.ttmesh.proto.ControlH\x00R\acontrol\x129\n" +
	"\tlease_req\x18\x0f \x01(\v2\x1a.ttmesh.proto.LeaseRequestH\x00R\bleaseReq\x127\n" +
	"\tlease_rep\x18\x10 \x01(\v2\x18.ttmesh.proto.LeaseReplyH\x00R\bleaseRep\x12\x12\n" +
	"\x03raw\x18\x11 \x01(\fH\x00R\x03raw\x12;\n" +
	"\vtiny_result\x18\x12 \x01(\v2\x18.ttmesh.proto.TinyResultH\x00R\n" +
	"tinyResult\x12>\n" +
	"\fsession_init\x18\x13 \x01(\v2\x19.ttmesh.proto.SessionInitH\x00R\vsessionInit\x12A\n" +
	"\rsession_close\x18\x14 \x01(\v2\x1a.ttmesh.proto.SessionCloseH\x00R\fsessionCloseB\x06\n" +
	"\x04body2F\n" +
	"\x04Mesh\x12>\n" +
	"\bExchange\x12\x16.ttmesh.proto.Envelope\x1a\x16.ttmesh.proto.Envelope(\x010\x01B'Z%ttmesh/pkg/protocol/proto;ttmeshprotob\x06proto3"

var (
	file_ttmesh_proto_rawDescOnce sync.Once
	file_ttmesh_proto_rawDescData []byte
)

func file_ttmesh_proto_rawDescGZIP() []byte {
	file_ttmesh_proto_rawDescOnce.Do(func() {
		file_ttmesh_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_ttmesh_proto_rawDesc), len(file_ttmesh_proto_rawDesc)))
	})
	return file_ttmesh_proto_rawDescData
}

var file_ttmesh_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_ttmesh_proto_goTypes = []any{
	(*Header)(nil),       // 0: ttmesh.proto.Header
	(*Envelope)(nil),     // 1: ttmesh.proto.Envelope
	nil,                  // 2: ttmesh.proto.Header.TagsEntry
	(MessageType)(0),     // 3: ttmesh.proto.MessageType
	(*NodeRef)(nil),      // 4: ttmesh.proto.NodeRef
	(Codec)(0),           // 5: ttmesh.proto.Codec
	(Compression)(0),     // 6: ttmesh.proto.Compression
	(Status)(0),          // 7: ttmesh.proto.Status
	(*Metadata)(nil),     // 8: ttmesh.proto.Metadata
	(*HopMeta)(nil),      // 9: ttmesh.proto.HopMeta
	(*BusHeader)(nil),    // 10: ttmesh.proto.BusHeader
	(*Invoke)(nil),       // 11: ttmesh.proto.Invoke
	(*ParamChunk)(nil),   // 12: ttmesh.proto.ParamChunk
	(*Result)(nil),       // 13: ttmesh.proto.Result
	(*Ack)(nil),          // 14: ttmesh.proto.Ack
	(*Control)(nil),      // 15: ttmesh.proto.Control
	(*LeaseRequest)(nil), // 16: ttmesh.proto.LeaseRequest
	(*LeaseReply)(nil),   // 17: ttmesh.proto.LeaseReply
	(*TinyResult)(nil),   // 18: ttmesh.proto.TinyResult
	(*SessionInit)(nil),  // 19: ttmesh.proto.SessionInit
	(*SessionClose)(nil), // 20: ttmesh.proto.SessionClose
}
var file_ttmesh_proto_depIdxs = []int32{
	3,  // 0: ttmesh.proto.Header.type:type_name -> ttmesh.proto.MessageType
	4,  // 1: ttmesh.proto.Header.source:type_name -> ttmesh.proto.NodeRef
	4,  // 2: ttmesh.proto.Header.dest:type_name -> ttmesh.proto.NodeRef
	4,  // 3: ttmesh.proto.Header.reply_to:type_name -> ttmesh.proto.NodeRef
	2,  // 4: ttmesh.proto.Header.tags:type_name -> ttmesh.proto.Header.TagsEntry
	5,  // 5: ttmesh.proto.Header.codec:type_name -> ttmesh.proto.Codec
	6,  // 6: ttmesh.proto.Header.compression:type_name -> ttmesh.proto.Compression
	7,  // 7: ttmesh.proto.Header.direct_status:type_name -> ttmesh.proto.Status
	0,  // 8: ttmesh.proto.Envelope.header:type_name -> ttmesh.proto.Header
	8,  // 9: ttmesh.proto.Envelope.meta:type_name -> ttmesh.proto.Metadata
	9,  // 10: ttmesh.proto.Envelope.hops:type_name -> ttmesh.proto.HopMeta
	10, // 11: ttmesh.proto.Envelope.bus:type_name -> ttmesh.proto.BusHeader
	11, // 12: ttmesh.proto.Envelope.invoke:type_name -> ttmesh.proto.Invoke
	12, // 13: ttmesh.proto.Envelope.chunk:type_name -> ttmesh.proto.ParamChunk
	13, // 14: ttmesh.proto.Envelope.result:type_name -> ttmesh.proto.Result
	14, // 15: ttmesh.proto.Envelope.ack:type_name -> ttmesh.proto.Ack
	15, // 16: ttmesh.proto.Envelope.control:type_name -> ttmesh.proto.Control
	16, // 17: ttmesh.proto.Envelope.lease_req:type_name -> ttmesh.proto.LeaseRequest
	17, // 18: ttmesh.proto.Envelope.lease_rep:type_name -> ttmesh.proto.LeaseReply
	18, // 19: ttmesh.proto.Envelope.tiny_result:type_name -> ttmesh.proto.TinyResult
	19, // 20: ttmesh.proto.Envelope.session_init:type_name -> ttmesh.proto.SessionInit
	20, // 21: ttmesh.proto.Envelope.session_close:type_name -> ttmesh.proto.SessionClose
	1,  // 22: ttmesh.proto.Mesh.Exchange:input_type -> ttmesh.proto.Envelope
	1,  // 23: ttmesh.proto.Mesh.Exchange:output_type -> ttmesh.proto.Envelope
	23, // [23:24] is the sub-list for method output_type
	22, // [22:23] is the sub-list for method input_type
	22, // [22:22] is the sub-list for extension type_name
	22, // [22:22] is the sub-list for extension extendee
	0,  // [0:22] is the sub-list for field type_name
}

func init() { file_ttmesh_proto_init() }
func file_ttmesh_proto_init() {
	if File_ttmesh_proto != nil {
		return
	}
	file_common_proto_init()
	file_routing_proto_init()
	file_task_proto_init()
	file_control_proto_init()
	file_tiny_proto_init()
	file_ttmesh_proto_msgTypes[0].OneofWrappers = []any{}
	file_ttmesh_proto_msgTypes[1].OneofWrappers = []any{
		(*Envelope_Invoke)(nil),
		(*Envelope_Chunk)(nil),
		(*Envelope_Result)(nil),
		(*Envelope_Ack)(nil),
		(*Envelope_Control)(nil),
		(*Envelope_LeaseReq)(nil),
		(*Envelope_LeaseRep)(nil),
		(*Envelope_Raw)(nil),
		(*Envelope_TinyResult)(nil),
		(*Envelope_SessionInit)(nil),
		(*Envelope_SessionClose)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_ttmesh_proto_rawDesc), len(file_ttmesh_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_ttmesh_proto_goTypes,
		DependencyIndexes: file_ttmesh_proto_depIdxs,
		MessageInfos:      file_ttmesh_proto_msgTypes,
	}.Build()
	File_ttmesh_proto = out.File
	file_ttmesh_proto_goTypes = nil
	file_ttmesh_proto_depIdxs = nil
}
