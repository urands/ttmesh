// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        v6.32.0
// source: common.proto

package ttmeshproto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Shared enums across the protocol
type MessageType int32

const (
	MessageType_MT_UNKNOWN      MessageType = 0
	MessageType_MT_TASK         MessageType = 1
	MessageType_MT_RESULT       MessageType = 2
	MessageType_MT_CONTROL      MessageType = 3
	MessageType_MT_HEARTBEAT    MessageType = 4
	MessageType_MT_ROUTE        MessageType = 5
	MessageType_MT_DAG_FRAGMENT MessageType = 6
)

// Enum value maps for MessageType.
var (
	MessageType_name = map[int32]string{
		0: "MT_UNKNOWN",
		1: "MT_TASK",
		2: "MT_RESULT",
		3: "MT_CONTROL",
		4: "MT_HEARTBEAT",
		5: "MT_ROUTE",
		6: "MT_DAG_FRAGMENT",
	}
	MessageType_value = map[string]int32{
		"MT_UNKNOWN":      0,
		"MT_TASK":         1,
		"MT_RESULT":       2,
		"MT_CONTROL":      3,
		"MT_HEARTBEAT":    4,
		"MT_ROUTE":        5,
		"MT_DAG_FRAGMENT": 6,
	}
)

func (x MessageType) Enum() *MessageType {
	p := new(MessageType)
	*p = x
	return p
}

func (x MessageType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MessageType) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[0].Descriptor()
}

func (MessageType) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[0]
}

func (x MessageType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MessageType.Descriptor instead.
func (MessageType) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{0}
}

type Status int32

const (
	Status_ST_OK       Status = 0
	Status_ST_PARTIAL  Status = 1
	Status_ST_RETRY    Status = 2
	Status_ST_FAILED   Status = 3
	Status_ST_CANCELED Status = 4
	Status_ST_TIMEOUT  Status = 5
)

// Enum value maps for Status.
var (
	Status_name = map[int32]string{
		0: "ST_OK",
		1: "ST_PARTIAL",
		2: "ST_RETRY",
		3: "ST_FAILED",
		4: "ST_CANCELED",
		5: "ST_TIMEOUT",
	}
	Status_value = map[string]int32{
		"ST_OK":       0,
		"ST_PARTIAL":  1,
		"ST_RETRY":    2,
		"ST_FAILED":   3,
		"ST_CANCELED": 4,
		"ST_TIMEOUT":  5,
	}
)

func (x Status) Enum() *Status {
	p := new(Status)
	*p = x
	return p
}

func (x Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Status) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[1].Descriptor()
}

func (Status) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[1]
}

func (x Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Status.Descriptor instead.
func (Status) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{1}
}

type AckCode int32

const (
	AckCode_ACK_OK   AckCode = 0
	AckCode_ACK_NACK AckCode = 1
)

// Enum value maps for AckCode.
var (
	AckCode_name = map[int32]string{
		0: "ACK_OK",
		1: "ACK_NACK",
	}
	AckCode_value = map[string]int32{
		"ACK_OK":   0,
		"ACK_NACK": 1,
	}
)

func (x AckCode) Enum() *AckCode {
	p := new(AckCode)
	*p = x
	return p
}

func (x AckCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AckCode) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[2].Descriptor()
}

func (AckCode) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[2]
}

func (x AckCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AckCode.Descriptor instead.
func (AckCode) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{2}
}

type FlowScope int32

const (
	FlowScope_FLOW_PARAM    FlowScope = 0
	FlowScope_FLOW_STEP     FlowScope = 1
	FlowScope_FLOW_WORKFLOW FlowScope = 2
)

// Enum value maps for FlowScope.
var (
	FlowScope_name = map[int32]string{
		0: "FLOW_PARAM",
		1: "FLOW_STEP",
		2: "FLOW_WORKFLOW",
	}
	FlowScope_value = map[string]int32{
		"FLOW_PARAM":    0,
		"FLOW_STEP":     1,
		"FLOW_WORKFLOW": 2,
	}
)

func (x FlowScope) Enum() *FlowScope {
	p := new(FlowScope)
	*p = x
	return p
}

func (x FlowScope) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FlowScope) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[3].Descriptor()
}

func (FlowScope) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[3]
}

func (x FlowScope) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FlowScope.Descriptor instead.
func (FlowScope) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{3}
}

type Codec int32

const (
	Codec_CODEC_RAW         Codec = 0
	Codec_CODEC_PROTOBUF    Codec = 1
	Codec_CODEC_CAPNPROTO   Codec = 2
	Codec_CODEC_FLATBUFFERS Codec = 3
)

// Enum value maps for Codec.
var (
	Codec_name = map[int32]string{
		0: "CODEC_RAW",
		1: "CODEC_PROTOBUF",
		2: "CODEC_CAPNPROTO",
		3: "CODEC_FLATBUFFERS",
	}
	Codec_value = map[string]int32{
		"CODEC_RAW":         0,
		"CODEC_PROTOBUF":    1,
		"CODEC_CAPNPROTO":   2,
		"CODEC_FLATBUFFERS": 3,
	}
)

func (x Codec) Enum() *Codec {
	p := new(Codec)
	*p = x
	return p
}

func (x Codec) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Codec) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[4].Descriptor()
}

func (Codec) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[4]
}

func (x Codec) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Codec.Descriptor instead.
func (Codec) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{4}
}

type Compression int32

const (
	Compression_COMP_NONE   Compression = 0
	Compression_COMP_ZSTD   Compression = 1
	Compression_COMP_SNAPPY Compression = 2
)

// Enum value maps for Compression.
var (
	Compression_name = map[int32]string{
		0: "COMP_NONE",
		1: "COMP_ZSTD",
		2: "COMP_SNAPPY",
	}
	Compression_value = map[string]int32{
		"COMP_NONE":   0,
		"COMP_ZSTD":   1,
		"COMP_SNAPPY": 2,
	}
)

func (x Compression) Enum() *Compression {
	p := new(Compression)
	*p = x
	return p
}

func (x Compression) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Compression) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[5].Descriptor()
}

func (Compression) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[5]
}

func (x Compression) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Compression.Descriptor instead.
func (Compression) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{5}
}

// PeerKind classifies peer role for routing decisions.
type PeerKind int32

const (
	PeerKind_PK_UNKNOWN       PeerKind = 0
	PeerKind_PK_CLIENT        PeerKind = 1
	PeerKind_PK_NODE          PeerKind = 2
	PeerKind_PK_RELAY         PeerKind = 3
	PeerKind_PK_PROXY         PeerKind = 4
	PeerKind_PK_OUTBOUND_ONLY PeerKind = 5 // NATed peer without listening port
)

// Enum value maps for PeerKind.
var (
	PeerKind_name = map[int32]string{
		0: "PK_UNKNOWN",
		1: "PK_CLIENT",
		2: "PK_NODE",
		3: "PK_RELAY",
		4: "PK_PROXY",
		5: "PK_OUTBOUND_ONLY",
	}
	PeerKind_value = map[string]int32{
		"PK_UNKNOWN":       0,
		"PK_CLIENT":        1,
		"PK_NODE":          2,
		"PK_RELAY":         3,
		"PK_PROXY":         4,
		"PK_OUTBOUND_ONLY": 5,
	}
)

func (x PeerKind) Enum() *PeerKind {
	p := new(PeerKind)
	*p = x
	return p
}

func (x PeerKind) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PeerKind) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[6].Descriptor()
}

func (PeerKind) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[6]
}

func (x PeerKind) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PeerKind.Descriptor instead.
func (PeerKind) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{6}
}

// HandshakeStatus reflects current handshake state for a session.
type HandshakeStatus int32

const (
	HandshakeStatus_HS_UNKNOWN  HandshakeStatus = 0
	HandshakeStatus_HS_HELLO_RX HandshakeStatus = 1
	HandshakeStatus_HS_VERIFIED HandshakeStatus = 2
	HandshakeStatus_HS_FAILED   HandshakeStatus = 3
)

// Enum value maps for HandshakeStatus.
var (
	HandshakeStatus_name = map[int32]string{
		0: "HS_UNKNOWN",
		1: "HS_HELLO_RX",
		2: "HS_VERIFIED",
		3: "HS_FAILED",
	}
	HandshakeStatus_value = map[string]int32{
		"HS_UNKNOWN":  0,
		"HS_HELLO_RX": 1,
		"HS_VERIFIED": 2,
		"HS_FAILED":   3,
	}
)

func (x HandshakeStatus) Enum() *HandshakeStatus {
	p := new(HandshakeStatus)
	*p = x
	return p
}

func (x HandshakeStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HandshakeStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[7].Descriptor()
}

func (HandshakeStatus) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[7]
}

func (x HandshakeStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HandshakeStatus.Descriptor instead.
func (HandshakeStatus) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{7}
}

type NodeRef struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`           // opaque node id
	Geohash       string                 `protobuf:"bytes,2,opt,name=geohash,proto3" json:"geohash,omitempty"` // optional region/geography hint
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeRef) Reset() {
	*x = NodeRef{}
	mi := &file_common_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeRef) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeRef) ProtoMessage() {}

func (x *NodeRef) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeRef.ProtoReflect.Descriptor instead.
func (*NodeRef) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{0}
}

func (x *NodeRef) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *NodeRef) GetGeohash() string {
	if x != nil {
		return x.Geohash
	}
	return ""
}

type RouteRef struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RouteId       string                 `protobuf:"bytes,1,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	Version       uint32                 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	Hash          []byte                 `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"` // optional integrity hash
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RouteRef) Reset() {
	*x = RouteRef{}
	mi := &file_common_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RouteRef) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteRef) ProtoMessage() {}

func (x *RouteRef) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteRef.ProtoReflect.Descriptor instead.
func (*RouteRef) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{1}
}

func (x *RouteRef) GetRouteId() string {
	if x != nil {
		return x.RouteId
	}
	return ""
}

func (x *RouteRef) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *RouteRef) GetHash() []byte {
	if x != nil {
		return x.Hash
	}
	return nil
}

type BlobRef struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`                                         // e.g., "sha256:..."
	Size          uint64                 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`                                    // 0 if unknown
	MediaType     string                 `protobuf:"bytes,3,opt,name=media_type,json=mediaType,proto3" json:"media_type,omitempty"`          // MIME
	SchemaRef     string                 `protobuf:"bytes,4,opt,name=schema_ref,json=schemaRef,proto3" json:"schema_ref,omitempty"`          // optional schema link
	IntegrityAlg  string                 `protobuf:"bytes,5,opt,name=integrity_alg,json=integrityAlg,proto3" json:"integrity_alg,omitempty"` // "sha256"/"blake3"
	Integrity     []byte                 `protobuf:"bytes,6,opt,name=integrity,proto3" json:"integrity,omitempty"`                           // object hash
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BlobRef) Reset() {
	*x = BlobRef{}
	mi := &file_common_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BlobRef) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlobRef) ProtoMessage() {}

func (x *BlobRef) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlobRef.ProtoReflect.Descriptor instead.
func (*BlobRef) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{2}
}

func (x *BlobRef) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *BlobRef) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *BlobRef) GetMediaType() string {
	if x != nil {
		return x.MediaType
	}
	return ""
}

func (x *BlobRef) GetSchemaRef() string {
	if x != nil {
		return x.SchemaRef
	}
	return ""
}

func (x *BlobRef) GetIntegrityAlg() string {
	if x != nil {
		return x.IntegrityAlg
	}
	return ""
}

func (x *BlobRef) GetIntegrity() []byte {
	if x != nil {
		return x.Integrity
	}
	return nil
}

type Metrics struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	CpuMs         uint64                 `protobuf:"varint,1,opt,name=cpu_ms,json=cpuMs,proto3" json:"cpu_ms,omitempty"`
	WallMs        uint64                 `protobuf:"varint,2,opt,name=wall_ms,json=wallMs,proto3" json:"wall_ms,omitempty"`
	MemPeakBytes  uint64                 `protobuf:"varint,3,opt,name=mem_peak_bytes,json=memPeakBytes,proto3" json:"mem_peak_bytes,omitempty"`
	Custom        map[string]string      `protobuf:"bytes,4,rep,name=custom,proto3" json:"custom,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // arbitrary metrics
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Metrics) Reset() {
	*x = Metrics{}
	mi := &file_common_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Metrics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Metrics) ProtoMessage() {}

func (x *Metrics) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Metrics.ProtoReflect.Descriptor instead.
func (*Metrics) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{3}
}

func (x *Metrics) GetCpuMs() uint64 {
	if x != nil {
		return x.CpuMs
	}
	return 0
}

func (x *Metrics) GetWallMs() uint64 {
	if x != nil {
		return x.WallMs
	}
	return 0
}

func (x *Metrics) GetMemPeakBytes() uint64 {
	if x != nil {
		return x.MemPeakBytes
	}
	return 0
}

func (x *Metrics) GetCustom() map[string]string {
	if x != nil {
		return x.Custom
	}
	return nil
}

type LogLine struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TsUnixMs      int64                  `protobuf:"varint,1,opt,name=ts_unix_ms,json=tsUnixMs,proto3" json:"ts_unix_ms,omitempty"`
	Level         string                 `protobuf:"bytes,2,opt,name=level,proto3" json:"level,omitempty"` // "INFO"/...
	Text          string                 `protobuf:"bytes,3,opt,name=text,proto3" json:"text,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogLine) Reset() {
	*x = LogLine{}
	mi := &file_common_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogLine) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogLine) ProtoMessage() {}

func (x *LogLine) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogLine.ProtoReflect.Descriptor instead.
func (*LogLine) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{4}
}

func (x *LogLine) GetTsUnixMs() int64 {
	if x != nil {
		return x.TsUnixMs
	}
	return 0
}

func (x *LogLine) GetLevel() string {
	if x != nil {
		return x.Level
	}
	return ""
}

func (x *LogLine) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

// PeerMeta describes peer identity and liveness metadata.
type PeerMeta struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	Id                 string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`                                                                                   // canonical peer id (e.g., pk:ed25519:...)
	NodeName           string                 `protobuf:"bytes,2,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`                                                       // optional human-friendly name
	Alg                string                 `protobuf:"bytes,3,opt,name=alg,proto3" json:"alg,omitempty"`                                                                                 // key algorithm (e.g., "ed25519")
	Pubkey             []byte                 `protobuf:"bytes,4,opt,name=pubkey,proto3" json:"pubkey,omitempty"`                                                                           // public key bytes
	Addresses          []string               `protobuf:"bytes,5,rep,name=addresses,proto3" json:"addresses,omitempty"`                                                                     // observed or advertised addresses
	Reachable          bool                   `protobuf:"varint,6,opt,name=reachable,proto3" json:"reachable,omitempty"`                                                                    // reachability hint
	Labels             map[string]string      `protobuf:"bytes,7,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // optional labels/tags
	Kind               PeerKind               `protobuf:"varint,8,opt,name=kind,proto3,enum=ttmesh.proto.PeerKind" json:"kind,omitempty"`                                                   // peer kind/role
	Handshake          HandshakeStatus        `protobuf:"varint,9,opt,name=handshake,proto3,enum=ttmesh.proto.HandshakeStatus" json:"handshake,omitempty"`                                  // handshake state
	MsgsIn             uint64                 `protobuf:"varint,10,opt,name=msgs_in,json=msgsIn,proto3" json:"msgs_in,omitempty"`                                                           // received message count
	MsgsOut            uint64                 `protobuf:"varint,11,opt,name=msgs_out,json=msgsOut,proto3" json:"msgs_out,omitempty"`                                                        // sent message count
	BytesIn            uint64                 `protobuf:"varint,12,opt,name=bytes_in,json=bytesIn,proto3" json:"bytes_in,omitempty"`                                                        // received bytes
	BytesOut           uint64                 `protobuf:"varint,13,opt,name=bytes_out,json=bytesOut,proto3" json:"bytes_out,omitempty"`                                                     // sent bytes
	LastHelloTs        int64                  `protobuf:"varint,14,opt,name=last_hello_ts,json=lastHelloTs,proto3" json:"last_hello_ts,omitempty"`                                          // last received hello
	LastAckTs          int64                  `protobuf:"varint,15,opt,name=last_ack_ts,json=lastAckTs,proto3" json:"last_ack_ts,omitempty"`                                                // last sent/received hello-ack
	ConnectedDirectIds []string               `protobuf:"bytes,16,rep,name=connected_direct_ids,json=connectedDirectIds,proto3" json:"connected_direct_ids,omitempty"`                      // direct connections to other peers (adjacency)
	Routes             []string               `protobuf:"bytes,17,rep,name=routes,proto3" json:"routes,omitempty"`                                                                          // known route identifiers
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *PeerMeta) Reset() {
	*x = PeerMeta{}
	mi := &file_common_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PeerMeta) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PeerMeta) ProtoMessage() {}

func (x *PeerMeta) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PeerMeta.ProtoReflect.Descriptor instead.
func (*PeerMeta) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{5}
}

func (x *PeerMeta) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *PeerMeta) GetNodeName() string {
	if x != nil {
		return x.NodeName
	}
	return ""
}

func (x *PeerMeta) GetAlg() string {
	if x != nil {
		return x.Alg
	}
	return ""
}

func (x *PeerMeta) GetPubkey() []byte {
	if x != nil {
		return x.Pubkey
	}
	return nil
}

func (x *PeerMeta) GetAddresses() []string {
	if x != nil {
		return x.Addresses
	}
	return nil
}

func (x *PeerMeta) GetReachable() bool {
	if x != nil {
		return x.Reachable
	}
	return false
}

func (x *PeerMeta) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *PeerMeta) GetKind() PeerKind {
	if x != nil {
		return x.Kind
	}
	return PeerKind_PK_UNKNOWN
}

func (x *PeerMeta) GetHandshake() HandshakeStatus {
	if x != nil {
		return x.Handshake
	}
	return HandshakeStatus_HS_UNKNOWN
}

func (x *PeerMeta) GetMsgsIn() uint64 {
	if x != nil {
		return x.MsgsIn
	}
	return 0
}

func (x *PeerMeta) GetMsgsOut() uint64 {
	if x != nil {
		return x.MsgsOut
	}
	return 0
}

func (x *PeerMeta) GetBytesIn() uint64 {
	if x != nil {
		return x.BytesIn
	}
	return 0
}

func (x *PeerMeta) GetBytesOut() uint64 {
	if x != nil {
		return x.BytesOut
	}
	return 0
}

func (x *PeerMeta) GetLastHelloTs() int64 {
	if x != nil {
		return x.LastHelloTs
	}
	return 0
}

func (x *PeerMeta) GetLastAckTs() int64 {
	if x != nil {
		return x.LastAckTs
	}
	return 0
}

func (x *PeerMeta) GetConnectedDirectIds() []string {
	if x != nil {
		return x.ConnectedDirectIds
	}
	return nil
}

func (x *PeerMeta) GetRoutes() []string {
	if x != nil {
		return x.Routes
	}
	return nil
}

var File_common_proto protoreflect.FileDescriptor

const file_common_proto_rawDesc = "" +
	"\n" +
	"\fcommon.proto\x12\fttmesh.proto\"3\n" +
	"\aNodeRef\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x18\n" +
	"\ageohash\x18\x02 \x01(\tR\ageohash\"S\n" +
	"\bRouteRef\x12\x19\n" +
	"\broute_id\x18\x01 \x01(\tR\arouteId\x12\x18\n" +
	"\aversion\x18\x02 \x01(\rR\aversion\x12\x12\n" +
	"\x04hash\x18\x03 \x01(\fR\x04hash\"\xae\x01\n" +
	"\aBlobRef\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04size\x18\x02 \x01(\x04R\x04size\x12\x1d\n" +
	"\n" +
	"media_type\x18\x03 \x01(\tR\tmediaType\x12\x1d\n" +
	"\n" +
	"schema_ref\x18\x04 \x01(\tR\tschemaRef\x12#\n" +
	"\rintegrity_alg\x18\x05 \x01(\tR\fintegrityAlg\x12\x1c\n" +
	"\tintegrity\x18\x06 \x01(\fR\tintegrity\"\xd5\x01\n" +
	"\aMetrics\x12\x15\n" +
	"\x06cpu_ms\x18\x01 \x01(\x04R\x05cpuMs\x12\x17\n" +
	"\awall_ms\x18\x02 \x01(\x04R\x06wallMs\x12$\n" +
	"\x0emem_peak_bytes\x18\x03 \x01(\x04R\fmemPeakBytes\x129\n" +
	"\x06custom\x18\x04 \x03(\v2!.ttmesh.proto.Metrics.CustomEntryR\x06custom\x1a9\n" +
	"\vCustomEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"Q\n" +
	"\aLogLine\x12\x1c\n" +
	"\n" +
	"ts_unix_ms\x18\x01 \x01(\x03R\btsUnixMs\x12\x14\n" +
	"\x05level\x18\x02 \x01(\tR\x05level\x12\x12\n" +
	"\x04text\x18\x03 \x01(\tR\x04text\"\xf7\x04\n" +
	"\bPeerMeta\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1b\n" +
	"\tnode_name\x18\x02 \x01(\tR\bnodeName\x12\x10\n" +
	"\x03alg\x18\x03 \x01(\tR\x03alg\x12\x16\n" +
	"\x06pubkey\x18\x04 \x01(\fR\x06pubkey\x12\x1c\n" +
	"\taddresses\x18\x05 \x03(\tR\taddresses\x12\x1c\n" +
	"\treachable\x18\x06 \x01(\bR\treachable\x12:\n" +
	"\x06labels\x18\a \x03(\v2\".ttmesh.proto.PeerMeta.LabelsEntryR\x06labels\x12*\n" +
	"\x04kind\x18\b \x01(\x0e2\x16.ttmesh.proto.PeerKindR\x04kind\x12;\n" +
	"\thandshake\x18\t \x01(\x0e2\x1d.ttmesh.proto.HandshakeStatusR\thandshake\x12\x17\n" +
	"\amsgs_in\x18\n" +
	" \x01(\x04R\x06msgsIn\x12\x19\n" +
	"\bmsgs_out\x18\v \x01(\x04R\amsgsOut\x12\x19\n" +
	"\bbytes_in\x18\f \x01(\x04R\abytesIn\x12\x1b\n" +
	"\tbytes_out\x18\r \x01(\x04R\bbytesOut\x12\"\n" +
	"\rlast_hello_ts\x18\x0e \x01(\x03R\vlastHelloTs\x12\x1e\n" +
	"\vlast_ack_ts\x18\x0f \x01(\x03R\tlastAckTs\x120\n" +
	"\x14connected_direct_ids\x18\x10 \x03(\tR\x12connectedDirectIds\x12\x16\n" +
	"\x06routes\x18\x11 \x03(\tR\x06routes\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01*~\n" +
	"\vMessageType\x12\x0e\n" +
	"\n" +
	"MT_UNKNOWN\x10\x00\x12\v\n" +
	"\aMT_TASK\x10\x01\x12\r\n" +
	"\tMT_RESULT\x10\x02\x12\x0e\n" +
	"\n" +
	"MT_CONTROL\x10\x03\x12\x10\n" +
	"\fMT_HEARTBEAT\x10\x04\x12\f\n" +
	"\bMT_ROUTE\x10\x05\x12\x13\n" +
	"\x0fMT_DAG_FRAGMENT\x10\x06*a\n" +
	"\x06Status\x12\t\n" +
	"\x05ST_OK\x10\x00\x12\x0e\n" +
	"\n" +
	"ST_PARTIAL\x10\x01\x12\f\n" +
	"\bST_RETRY\x10\x02\x12\r\n" +
	"\tST_FAILED\x10\x03\x12\x0f\n" +
	"\vST_CANCELED\x10\x04\x12\x0e\n" +
	"\n" +
	"ST_TIMEOUT\x10\x05*#\n" +
	"\aAckCode\x12\n" +
	"\n" +
	"\x06ACK_OK\x10\x00\x12\f\n" +
	"\bACK_NACK\x10\x01*=\n" +
	"\tFlowScope\x12\x0e\n" +
	"\n" +
	"FLOW_PARAM\x10\x00\x12\r\n" +
	"\tFLOW_STEP\x10\x01\x12\x11\n" +
	"\rFLOW_WORKFLOW\x10\x02*V\n" +
	"\x05Codec\x12\r\n" +
	"\tCODEC_RAW\x10\x00\x12\x12\n" +
	"\x0eCODEC_PROTOBUF\x10\x01\x12\x13\n" +
	"\x0fCODEC_CAPNPROTO\x10\x02\x12\x15\n" +
	"\x11CODEC_FLATBUFFERS\x10\x03*<\n" +
	"\vCompression\x12\r\n" +
	"\tCOMP_NONE\x10\x00\x12\r\n" +
	"\tCOMP_ZSTD\x10\x01\x12\x0f\n" +
	"\vCOMP_SNAPPY\x10\x02*h\n" +
	"\bPeerKind\x12\x0e\n" +
	"\n" +
	"PK_UNKNOWN\x10\x00\x12\r\n" +
	"\tPK_CLIENT\x10\x01\x12\v\n" +
	"\aPK_NODE\x10\x02\x12\f\n" +
	"\bPK_RELAY\x10\x03\x12\f\n" +
	"\bPK_PROXY\x10\x04\x12\x14\n" +
	"\x10PK_OUTBOUND_ONLY\x10\x05*R\n" +
	"\x0fHandshakeStatus\x12\x0e\n" +
	"\n" +
	"HS_UNKNOWN\x10\x00\x12\x0f\n" +
	"\vHS_HELLO_RX\x10\x01\x12\x0f\n" +
	"\vHS_VERIFIED\x10\x02\x12\r\n" +
	"\tHS_FAILED\x10\x03B'Z%ttmesh/pkg/protocol/proto;ttmeshprotob\x06proto3"

var (
	file_common_proto_rawDescOnce sync.Once
	file_common_proto_rawDescData []byte
)

func file_common_proto_rawDescGZIP() []byte {
	file_common_proto_rawDescOnce.Do(func() {
		file_common_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_common_proto_rawDesc), len(file_common_proto_rawDesc)))
	})
	return file_common_proto_rawDescData
}

var file_common_proto_enumTypes = make([]protoimpl.EnumInfo, 8)
var file_common_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_common_proto_goTypes = []any{
	(MessageType)(0),     // 0: ttmesh.proto.MessageType
	(Status)(0),          // 1: ttmesh.proto.Status
	(AckCode)(0),         // 2: ttmesh.proto.AckCode
	(FlowScope)(0),       // 3: ttmesh.proto.FlowScope
	(Codec)(0),           // 4: ttmesh.proto.Codec
	(Compression)(0),     // 5: ttmesh.proto.Compression
	(PeerKind)(0),        // 6: ttmesh.proto.PeerKind
	(HandshakeStatus)(0), // 7: ttmesh.proto.HandshakeStatus
	(*NodeRef)(nil),      // 8: ttmesh.proto.NodeRef
	(*RouteRef)(nil),     // 9: ttmesh.proto.RouteRef
	(*BlobRef)(nil),      // 10: ttmesh.proto.BlobRef
	(*Metrics)(nil),      // 11: ttmesh.proto.Metrics
	(*LogLine)(nil),      // 12: ttmesh.proto.LogLine
	(*PeerMeta)(nil),     // 13: ttmesh.proto.PeerMeta
	nil,                  // 14: ttmesh.proto.Metrics.CustomEntry
	nil,                  // 15: ttmesh.proto.PeerMeta.LabelsEntry
}
var file_common_proto_depIdxs = []int32{
	14, // 0: ttmesh.proto.Metrics.custom:type_name -> ttmesh.proto.Metrics.CustomEntry
	15, // 1: ttmesh.proto.PeerMeta.labels:type_name -> ttmesh.proto.PeerMeta.LabelsEntry
	6,  // 2: ttmesh.proto.PeerMeta.kind:type_name -> ttmesh.proto.PeerKind
	7,  // 3: ttmesh.proto.PeerMeta.handshake:type_name -> ttmesh.proto.HandshakeStatus
	4,  // [4:4] is the sub-list for method output_type
	4,  // [4:4] is the sub-list for method input_type
	4,  // [4:4] is the sub-list for extension type_name
	4,  // [4:4] is the sub-list for extension extendee
	0,  // [0:4] is the sub-list for field type_name
}

func init() { file_common_proto_init() }
func file_common_proto_init() {
	if File_common_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_common_proto_rawDesc), len(file_common_proto_rawDesc)),
			NumEnums:      8,
			NumMessages:   8,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_common_proto_goTypes,
		DependencyIndexes: file_common_proto_depIdxs,
		EnumInfos:         file_common_proto_enumTypes,
		MessageInfos:      file_common_proto_msgTypes,
	}.Build()
	File_common_proto = out.File
	file_common_proto_goTypes = nil
	file_common_proto_depIdxs = nil
}
